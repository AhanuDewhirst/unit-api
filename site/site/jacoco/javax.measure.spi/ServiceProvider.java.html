<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ServiceProvider.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Units of Measurement API</a> &gt; <a href="index.source.html" class="el_package">javax.measure.spi</a> &gt; <span class="el_source">ServiceProvider.java</span></div><h1>ServiceProvider.java</h1><pre class="source lang-java linenums">/*
 * Units of Measurement API
 * Copyright (c) 2014-2018, Jean-Marie Dautelle, Werner Keil, Otavio Santana.
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions
 *    and the following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of JSR-385 nor the names of its contributors may be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package javax.measure.spi;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.ServiceLoader;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.measure.Quantity;
import javax.measure.format.UnitFormat;

/**
 * Service Provider for Units of Measurement services.
 * &lt;p&gt;
 * All the methods in this class are safe to use by multiple concurrent threads.
 *
 * @version 1.0, August 8, 2016
 * @author Werner Keil
 * @author Martin Desruisseaux
 * @since 1.0
 */
public abstract class ServiceProvider {
  /**
   * Synchronization lock for searching or setting the service providers.
   */
<span class="fc" id="L56">  private static final Object LOCK = new Object();</span>

  /**
   * All service providers found, sorted in preference order. Array content shall never been changed after initialization; if we want to change the
   * array content, a new array shall be created.
   */
  private static volatile ServiceProvider[] providers;

  /**
   * Creates a new service provider. Only to be used by subclasses.
   */
<span class="fc" id="L67">  protected ServiceProvider() {</span>
<span class="fc" id="L68">  }</span>

  /**
   * This method allows to define a priority for a registered ServiceProvider instance. When multiple providers are registered in the system the
   * provider with the highest priority value is taken.
   *
   * @return the provider's priority (default is 0).
   */
  public int getPriority() {
<span class="nc" id="L77">    return 0;</span>
  }

  /**
   * Returns the service to obtain a {@link SystemOfUnits}, or {@code null} if none.
   *
   * @return the service to obtain a {@link SystemOfUnits}, or {@code null}.
   */
  public abstract SystemOfUnitsService getSystemOfUnitsService();

  /**
   * Returns the service to obtain a {@link UnitFormat}, or {@code null} if none.
   *
   * @return the service to obtain a {@link UnitFormat}, or {@code null}.
   */
  public abstract UnitFormatService getUnitFormatService();

  /**
   * Return a factory for this {@link Quantity}.
   *
   * @param &lt;Q&gt;
   *          the type of the {@link Quantity} result
   * @param quantity
   *          the quantity
   * @return the {@link QuantityFactory}
   */
  public abstract &lt;Q extends Quantity&lt;Q&gt;&gt; QuantityFactory&lt;Q&gt; getQuantityFactory(Class&lt;Q&gt; quantity);

  /**
   * Gets all {@link ServiceProvider}. This method loads the provider when first needed.
   */
  private static ServiceProvider[] getProviders() {
<span class="fc" id="L109">    ServiceProvider[] p = providers;</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">    if (p == null) {</span>
<span class="fc" id="L111">      synchronized (LOCK) {</span>
<span class="fc" id="L112">        p = providers;</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (p == null) {</span>
<span class="fc" id="L114">          final List&lt;ServiceProvider&gt; loaded = new ArrayList&lt;ServiceProvider&gt;();</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">          for (ServiceProvider provider : ServiceLoader.load(ServiceProvider.class)) {</span>
<span class="nc" id="L116">            loaded.add(provider);</span>
<span class="nc" id="L117">          }</span>
<span class="fc" id="L118">          p = loaded.toArray(new ServiceProvider[loaded.size()]);</span>
<span class="fc" id="L119">          Arrays.sort(p, new Comparator&lt;ServiceProvider&gt;() {</span>
            @Override
            public int compare(ServiceProvider p1, ServiceProvider p2) {
<span class="nc" id="L122">              return p2.getPriority() - p1.getPriority();</span>
            }
          });
<span class="fc" id="L125">          providers = p; // Set only on success.</span>
        }
<span class="pc" id="L127">      }</span>
    }
<span class="fc" id="L129">    return p;</span>
  }

  /**
   * Returns the list of available service providers.
   *
   * @return all available service providers.
   */
  public static List&lt;ServiceProvider&gt; available() {
<span class="fc" id="L138">    return Arrays.asList(getProviders());</span>
  }

  /**
   * Returns the current {@link ServiceProvider}. If necessary the {@link ServiceProvider} will be lazily loaded.
   * &lt;p&gt;
   * If there are no providers available, an {@linkplain IllegalStateException} is thrown, otherwise the provider with the highest priority is used or
   * the one explicitly designated via {@link #setCurrent(ServiceProvider)} .
   * &lt;/p&gt;
   * 
   * @return the {@link ServiceProvider} used.
   * @throws IllegalStateException
   *           if no {@link ServiceProvider} has been found.
   * @see #getPriority()
   * @see #setCurrent(ServiceProvider)
   */
  public static ServiceProvider current() {
<span class="fc" id="L155">    ServiceProvider[] p = getProviders();</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">    if (p.length != 0) {</span>
<span class="fc" id="L157">      return p[0];</span>
    }
<span class="fc" id="L159">    throw new IllegalStateException(&quot;No measurement ServiceProvider found.&quot;);</span>
  }

  /**
   * Replaces the current {@link ServiceProvider}.
   *
   * @param provider
   *          the new {@link ServiceProvider}
   * @return the replaced provider, or null.
   */
  public static ServiceProvider setCurrent(ServiceProvider provider) {
<span class="fc bfc" id="L170" title="All 2 branches covered.">    if (provider == null) {</span>
<span class="fc" id="L171">      throw new NullPointerException();</span>
    }
<span class="fc" id="L173">    synchronized (LOCK) {</span>
<span class="fc" id="L174">      ServiceProvider[] p = getProviders();</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">      ServiceProvider old = (p.length != 0) ? p[0] : null;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">      if (provider != old) {</span>
<span class="fc" id="L177">        List&lt;ServiceProvider&gt; copy = new ArrayList&lt;ServiceProvider&gt;(Arrays.asList(p));</span>
<span class="fc" id="L178">        copy.remove(provider);</span>
<span class="fc" id="L179">        copy.add(0, provider);</span>
<span class="fc" id="L180">        providers = copy.toArray(new ServiceProvider[copy.size()]);</span>

        // Keep the log inside the synchronized block for making sure that the order
        // or logging messages matches the order in which ServiceProviders were set.
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        Logger.getLogger(&quot;javax.measure.spi&quot;).log(Level.CONFIG,</span>
<span class="fc" id="L185">            (old == null) ? &quot;Measurement ServiceProvider set to {0}&quot; : &quot;Measurement ServiceProvider replaced by {0}&quot;, provider.getClass().getName());</span>
      }
<span class="fc" id="L187">      return old;</span>
<span class="nc" id="L188">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>